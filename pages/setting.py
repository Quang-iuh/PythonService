import streamlit as st
import pymodbus
from pymodbus.client import ModbusTcpClient
from pymodbus.exceptions import ModbusException, ConnectionException
import pandas as pd
import socket
import time
from Component.Camera.CameraHeader import load_css
from pages.Dashboard import qr_history, total_scans, unique_scans, unique_north, unique_central, unique_south

# --- C·∫•u h√¨nh trang ---
st.set_page_config(
    page_title="‚öôÔ∏è C√†i ƒë·∫∑t h·ªá th·ªëng",
    layout="wide",
    initial_sidebar_state="expanded"
)
load_css("SettingStyle.css")


# PLC Manager Class v·ªõi Modbus TCP - C·∫£i ti·∫øn
class PLCManager:
    def __init__(self):
        self.client = None
        self.connected = False
        self.ip = None
        self.port = 102
        self.timeout = 10
        self.retry_count = 3

    def test_network_connectivity(self, ip, port, timeout=5):
        """Test basic network connectivity before Modbus connection"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            result = sock.connect_ex((ip, port))
            sock.close()
            return result == 0
        except Exception as e:
            st.error(f"Network test failed: {str(e)}")
            return False

    def connect(self, ip, port=102):
        """K·∫øt n·ªëi ƒë·∫øn PLC qua Modbus TCP v·ªõi retry mechanism"""
        self.ip = ip
        self.port = port

        # Test network connectivity first
        st.info(f"üîç Testing network connectivity to {ip}:{port}...")
        if not self.test_network_connectivity(ip, port):
            return False, f"Cannot reach {ip}:{port}. Check network connection and PLC IP address."

        st.success("‚úÖ Network connectivity OK")

        # Try Modbus connection with retry
        for attempt in range(self.retry_count):
            try:
                st.info(f"üîÑ Modbus connection attempt {attempt + 1}/{self.retry_count}...")

                self.client = ModbusTcpClient(
                    host=ip,
                    port=port,
                    timeout=self.timeout,
                    retry_on_empty=True,
                    retry_on_invalid=True,
                    retries=1
                )

                self.connected = self.client.connect()

                if self.connected:
                    # Test read to verify connection works
                    try:
                        test_result = self.client.read_holding_registers(0, 1, unit=1)
                        if not test_result.isError():
                            st.success("‚úÖ Modbus connection established and verified")
                            return True, "K·∫øt n·ªëi PLC th√†nh c√¥ng"
                        else:
                            st.warning(f"Connection established but test read failed: {test_result}")
                    except Exception as e:
                        st.warning(f"Connection established but verification failed: {str(e)}")

                    return True, "K·∫øt n·ªëi PLC th√†nh c√¥ng (v·ªõi c·∫£nh b√°o)"
                else:
                    if attempt < self.retry_count - 1:
                        st.warning(f"Attempt {attempt + 1} failed, retrying in 2 seconds...")
                        time.sleep(2)

            except ConnectionException as e:
                error_msg = f"Connection error on attempt {attempt + 1}: {str(e)}"
                if attempt < self.retry_count - 1:
                    st.warning(f"{error_msg}, retrying...")
                    time.sleep(2)
                else:
                    st.error(error_msg)

            except Exception as e:
                error_msg = f"Unexpected error on attempt {attempt + 1}: {str(e)}"
                if attempt < self.retry_count - 1:
                    st.warning(f"{error_msg}, retrying...")
                    time.sleep(2)
                else:
                    st.error(error_msg)

        self.connected = False
        return False, f"Failed to connect after {self.retry_count} attempts. Check PLC configuration and Modbus TCP settings."

    def disconnect(self):
        """Ng·∫Øt k·∫øt n·ªëi PLC"""
        if self.client and self.connected:
            try:
                self.client.close()
                self.connected = False
                st.info("PLC disconnected successfully")
            except Exception as e:
                st.error(f"Error during disconnect: {str(e)}")
                self.connected = False

    def read_motor_speed(self, address=0, unit=1):
        """ƒê·ªçc t·ªëc ƒë·ªô ƒë·ªông c∆° t·ª´ PLC (Holding Register)"""
        if not self.connected:
            st.error("PLC not connected")
            return None

        try:
            # ƒê·ªçc 2 registers ƒë·ªÉ l·∫•y float value (32-bit)
            result = self.client.read_holding_registers(address, 2, unit=unit)
            if result.isError():
                st.error(f"L·ªói ƒë·ªçc PLC: {result}")
                return None

                # Convert 2 registers to float (IEEE 754)
            registers = result.registers
            speed = self._registers_to_float(registers[0], registers[1])
            return speed

        except ModbusException as e:
            st.error(f"L·ªói Modbus: {e}")
            return None
        except Exception as e:
            st.error(f"L·ªói ƒë·ªçc d·ªØ li·ªáu PLC: {e}")
            return None

    def write_motor_speed(self, speed, address=0, unit=1):
        """Ghi t·ªëc ƒë·ªô ƒë·ªông c∆° v√†o PLC (Holding Register)"""
        if not self.connected:
            st.error("PLC not connected")
            return False

        try:
            # Convert float to 2 registers (IEEE 754)
            reg1, reg2 = self._float_to_registers(speed)

            # Ghi 2 registers
            result = self.client.write_registers(address, [reg1, reg2], unit=unit)
            if result.isError():
                st.error(f"L·ªói ghi PLC: {result}")
                return False

            st.success(f"Motor speed written successfully: {speed}")
            return True

        except ModbusException as e:
            st.error(f"L·ªói Modbus: {e}")
            return False
        except Exception as e:
            st.error(f"L·ªói ghi d·ªØ li·ªáu PLC: {e}")
            return False

    def write_package_data(self, package_id, region_code, unit=1):
        """Ghi data package cho counter-based approach"""
        if not self.connected:
            st.error("PLC not connected")
            return False

        try:
            # Ghi Package ID v√†o DB1 (address 0)
            result1 = self.client.write_registers(0, [package_id], unit=unit)
            # Ghi Region Code v√†o DB2 (address 1)
            result2 = self.client.write_registers(1, [region_code], unit=unit)

            if result1.isError() or result2.isError():
                st.error(f"Error writing package data: DB1={result1}, DB2={result2}")
                return False

            st.success(f"Package data written: ID={package_id}, Region={region_code}")
            return True

        except Exception as e:
            st.error(f"Error writing package data: {str(e)}")
            return False

    def read_digital_input(self, address, unit=1):
        """ƒê·ªçc digital input t·ª´ PLC"""
        if not self.connected:
            return None

        try:
            result = self.client.read_discrete_inputs(address, 1, unit=unit)
            if result.isError():
                return None
            return result.bits[0]
        except Exception as e:
            st.error(f"L·ªói ƒë·ªçc digital input: {e}")
            return None

    def write_digital_output(self, address, value, unit=1):
        """Ghi digital output v√†o PLC"""
        if not self.connected:
            return False

        try:
            result = self.client.write_coil(address, value, unit=unit)
            return not result.isError()
        except Exception as e:
            st.error(f"L·ªói ghi digital output: {e}")
            return False

    def get_connection_status(self):
        """Ki·ªÉm tra tr·∫°ng th√°i k·∫øt n·ªëi"""
        return {
            "connected": self.connected,
            "ip": self.ip,
            "port": self.port,
            "timeout": self.timeout,
            "retry_count": self.retry_count
        }

    def write_db(self, db_number, start_offset, data):
        """Ghi data v√†o Data Block c·ªßa PLC"""
        if not self.connected:
            return False

        try:
            self.client.db_write(db_number, start_offset, data)
            return True
        except Exception as e:
            st.error(f"L·ªói ghi DB{db_number}: {str(e)}")
            return False

    def read_db(self, db_number, start_offset, size):
        """ƒê·ªçc data t·ª´ Data Block c·ªßa PLC"""
        if not self.connected:
            return None

        try:
            data = self.client.db_read(db_number, start_offset, size)
            return data
        except Exception as e:
            st.error(f"L·ªói ƒë·ªçc DB{db_number}: {str(e)}")
            return None

    def _float_to_registers(self, value):
        """Convert float to 2 Modbus registers (IEEE 754)"""
        import struct
        # Pack float as big-endian IEEE 754
        packed = struct.pack('>f', value)
        # Unpack as 2 16-bit integers
        reg1, reg2 = struct.unpack('>HH', packed)
        return reg1, reg2

    def _registers_to_float(self, reg1, reg2):
        """Convert 2 Modbus registers to float (IEEE 754)"""
        import struct
        # Pack 2 16-bit integers
        packed = struct.pack('>HH', reg1, reg2)
        # Unpack as big-endian float
        value = struct.unpack('>f', packed)[0]
        return value

    # --- Header ch√≠nh ---


st.markdown("""      
<div class="main-header">      
    <h1>‚öôÔ∏è C√ÄI ƒê·∫∂T H·ªÜ TH·ªêNG</h1>      
    <p>ƒêi·ªÅu ch·ªânh th√¥ng s·ªë v√† c·∫•u h√¨nh ·ª©ng d·ª•ng</p>      
</div>      
""", unsafe_allow_html=True)

# --- Ki·ªÉm tra ƒëƒÉng nh·∫≠p ---
if 'logged_in' not in st.session_state or not st.session_state.logged_in:
    st.error("üîí Vui l√≤ng ƒëƒÉng nh·∫≠p tr∆∞·ªõc khi truy c·∫≠p trang n√†y.")
    st.stop()

# --- Kh·ªüi t·∫°o session state ---
if "grayscale" not in st.session_state:
    st.session_state.grayscale = False
if "resolution" not in st.session_state:
    st.session_state.resolution = (640, 480)
if 'zoom_level' not in st.session_state:
    st.session_state.zoom_level = 1.0
if 'speed_motor' not in st.session_state:
    st.session_state.speed_motor = 2.5

# PLC session state
if 'plc_connected' not in st.session_state:
    st.session_state.plc_connected = False
if 'plc_ip' not in st.session_state:
    st.session_state.plc_ip = "192.168.0.1"  # Updated default IP
if 'plc_port' not in st.session_state:
    st.session_state.plc_port = 102
if 'plc_unit_id' not in st.session_state:
    st.session_state.plc_unit_id = 1

# --- Layout 2 c·ªôt ---
col1, col2 = st.columns([1, 1])

with col1:
    # --- C√†i ƒë·∫∑t Camera ---
    st.markdown("""      
    <div class="setting-card">      
        <h3 class="setting-title">üìπ C√†i ƒë·∫∑t Camera</h3>      
    </div>      
    """, unsafe_allow_html=True)

    # Grayscale
    st.session_state.grayscale = st.checkbox(
        "üé® B·∫≠t ch·∫ø ƒë·ªô Grayscale",
        value=st.session_state.grayscale,
        help="Chuy·ªÉn ƒë·ªïi h√¨nh ·∫£nh sang m√†u x√°m"
    )

    # Zoom level
    st.markdown("**üîç ƒêi·ªÅu ch·ªânh ƒë·ªô ph√≥ng ƒë·∫°i**")
    st.session_state.zoom_level = st.slider(
        "M·ª©c ph√≥ng ƒë·∫°i camera:",
        min_value=1.0,
        max_value=3.0,
        value=st.session_state.zoom_level,
        step=0.1,
        help="1.0 = Zoom m·∫∑c ƒë·ªãnh, gi√° tr·ªã l·ªõn h∆°n s·∫Ω ph√≥ng to h√¨nh ·∫£nh"
    )

    # Resolution
    st.markdown("**üìê ƒê·ªô ph√¢n gi·∫£i**")
    resolution_options = {
        "640x480 (SD)": (640, 480),
        "1280x720 (HD)": (1280, 720),
        "1920x1080 (Full HD)": (1920, 1080)
    }

    current_res = f"{st.session_state.resolution[0]}x{st.session_state.resolution[1]}"
    for key, value in resolution_options.items():
        if value == st.session_state.resolution:
            current_res = key
            break

    selected_res = st.selectbox(
        "Ch·ªçn ƒë·ªô ph√¢n gi·∫£i:",
        list(resolution_options.keys()),
        index=list(resolution_options.keys()).index(current_res) if current_res in resolution_options.keys() else 0
    )
    st.session_state.resolution = resolution_options[selected_res]

with col2:
    # --- C√†i ƒë·∫∑t ƒê·ªông c∆° ---
    st.markdown("""      
    <div class="setting-card">      
        <h3 class="setting-title">‚ö° C√†i ƒë·∫∑t ƒê·ªông c∆°</h3>      
    </div>      
    """, unsafe_allow_html=True)

    st.markdown("**üöÄ T·ªëc ƒë·ªô ƒë·ªông c∆°**")
    st.session_state.speed_motor = st.slider(
        "T·ªëc ƒë·ªô (m/ph√∫t):",
        min_value=2.5,
        max_value=5.0,
        value=st.session_state.speed_motor,
        step=0.1,
        help="ƒêi·ªÅu ch·ªânh t·ªëc ƒë·ªô ho·∫°t ƒë·ªông c·ªßa ƒë·ªông c∆°"
    )
    # --- C√†i ƒë·∫∑t PLC --- (ti·∫øp theo)
    st.markdown("""      
        <div class="setting-card">      
            <h3 class="setting-title">üîå K·∫øt n·ªëi PLC Modbus</h3>      
        </div>      
        """, unsafe_allow_html=True)

    # PLC Connection Settings
    st.markdown("**üåê Th√¥ng s·ªë k·∫øt n·ªëi**")

    col_ip, col_port = st.columns([2, 1])
    with col_ip:
        st.session_state.plc_ip = st.text_input(
            "ƒê·ªãa ch·ªâ IP PLC:",
            value=st.session_state.plc_ip,
            help="Nh·∫≠p ƒë·ªãa ch·ªâ IP c·ªßa PLC"
        )

    with col_port:
        st.session_state.plc_port = st.number_input(
            "Port:",
            min_value=0,
            max_value=65535,
            value=st.session_state.plc_port
        )

    st.session_state.plc_unit_id = st.number_input(
        "Unit ID:",
        min_value=1,
        max_value=255,
        value=st.session_state.plc_unit_id,
        help="Modbus Unit ID (th∆∞·ªùng l√† 1)"
    )

    # Connection Controls
    col_connect, col_disconnect = st.columns(2)

    with col_connect:
        if st.button("üîó K·∫øt n·ªëi PLC", use_container_width=True):
            if 'plc_manager' not in st.session_state:
                st.session_state.plc_manager = PLCManager()

            success, message = st.session_state.plc_manager.connect(
                st.session_state.plc_ip,
                st.session_state.plc_port
            )

            if success:
                st.session_state.plc_connected = True
                st.success(message)
            else:
                st.session_state.plc_connected = False
                st.error(message)

    with col_disconnect:
        if st.button("‚ùå Ng·∫Øt k·∫øt n·ªëi", use_container_width=True):
            if 'plc_manager' in st.session_state:
                st.session_state.plc_manager.disconnect()
                st.session_state.plc_connected = False
                st.warning("ƒê√£ ng·∫Øt k·∫øt n·ªëi PLC")

                # Status Display
    if st.session_state.plc_connected:
        st.success("üü¢ PLC ƒë√£ k·∫øt n·ªëi")

        # Test connection button
        if st.button("üß™ Test k·∫øt n·ªëi", use_container_width=True):
            if 'plc_manager' in st.session_state:
                status = st.session_state.plc_manager.get_connection_status()
                test_result = (status["connected"], "Connection OK" if status["connected"] else "Not connected")
                if test_result:
                    st.success("‚úÖ Test k·∫øt n·ªëi th√†nh c√¥ng")
                else:
                    st.error("‚ùå Test k·∫øt n·ªëi th·∫•t b·∫°i")
    else:
        st.error("üî¥ PLC ch∆∞a k·∫øt n·ªëi")

        # Reset Settings
st.markdown("---")
if st.button("üîÑ Reset v·ªÅ m·∫∑c ƒë·ªãnh", use_container_width=True):
    st.session_state.grayscale = False
    st.session_state.zoom_level = 1.0
    st.session_state.resolution = (640, 480)
    st.session_state.speed_motor = 2.5
    st.session_state.plc_connected = False
    st.session_state.plc_ip = "192.168.1.100"
    st.session_state.plc_port = 102
    st.session_state.plc_unit_id = 1
    st.success("ƒê√£ reset v·ªÅ c√†i ƒë·∫∑t m·∫∑c ƒë·ªãnh!")
    st.rerun()

    # Sidebar
with st.sidebar:
    st.markdown(f"""          
        <div class="sidebar-section">          
            <h3>üë§ Ng∆∞·ªùi d√πng</h3>          
            <p>Xin ch√†o, <strong>{st.session_state.get('username', 'User')}</strong></p>          
        </div>          
        """, unsafe_allow_html=True)

    st.markdown("""          
        <div class="sidebar-section">          
            <h3>üìä Th·ªëng k√™ nhanh</h3>          
        </div>          
        """, unsafe_allow_html=True)

    if qr_history:
        st.metric("T·ªïng qu√©t", total_scans)
        st.metric("M√£ duy nh·∫•t", unique_scans)

        # T·ª∑ l·ªá ph·∫ßn trƒÉm
        if total_scans > 0:
            north_pct = round(len(unique_north) / unique_scans * 100, 1) if unique_scans > 0 else 0
            central_pct = round(len(unique_central) / unique_scans * 100, 1) if unique_scans > 0 else 0
            south_pct = round(len(unique_south) / unique_scans * 100, 1) if unique_scans > 0 else 0

            st.write("**T·ª∑ l·ªá theo mi·ªÅn:**")
            st.write(f"üîµ Mi·ªÅn B·∫Øc: {north_pct}%")
            st.write(f"üü° Mi·ªÅn Trung: {central_pct}%")
            st.write(f"üî¥ Mi·ªÅn Nam: {south_pct}%")

    st.markdown("---")

    if st.button("üîí ƒêƒÉng xu·∫•t", use_container_width=True):
        st.session_state.logged_in = False
        st.session_state.username = ""
        st.switch_page("pages/login.py")